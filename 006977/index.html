<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"><html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en"><head><title>Keeping 'fake' simple - lingbuzz/006977</title><meta http-equiv="Content-Type" content="text/html;charset=utf-8"/><meta http-equiv="Content-Script-Type" content="text/javascript"/><link rel="canonical" href="/lingbuzz/006977"/><meta name="description" content="In this paper, I argue against two common claims about privatives like 'fake': first, I argue against the idea that the semantic complexity of 'fake' requires a richer notion of lexical meaning than t - lingbuzz, the linguistics archive"/><link rel="stylesheet" type="text/css" href="/buzzdocs/styles/article-editor.css"/><link rel="stylesheet" type="text/css" href="/lingbuzz"/></head><body alink="#111111" vlink="#333344" link="#3333AA" onload="onLoad()">&nbsp;<p></p><center><font size="+1"><b><a href="/lingbuzz/006977/current.pdf">Keeping 'fake' simple</a></b></font><br/><a href="/lingbuzz/006977">Janek Guerrini</a><br/>March 2024</center>&nbsp;<p></p>In this paper, I argue against two common claims about privatives like 'fake': first, I argue against the idea that the semantic complexity of 'fake' requires a richer notion of lexical meaning than the standard notion (see, e.g., Del Pinal, 2018); second, I argue against the idea that 'fake' does not semantically negate its input and rather behaves like a subsective (see, e.g., Partee, 2010). I propose that a fake P is (i) intended to resemble a P and (ii) is not a P. This makes correct predictions for multiple applications of 'fake', a task at which other theories fail. In double application of 'fake', the interaction between the conjunctive meaning of 'fake' and the negation hard-coded into clause (ii) yields a complex meaning, compatible with a variety of objects. While the core meaning of 'fake' is quite simple, its mode of composition bears some complexity. I propose that 'fake' can alternatively (a) combine directly with the noun via Functional Application or (b) saturate its property argument via an implicit, contextually provided variable via Functional Application and then combine with the noun via Predicate Modification (cf. Martin, 2022 for a similar view). Mode of composition (a) is clearly visible in syntactic parses that only allow for Functional Application: for instance, in Italian, if prenominal, 'fake' can only directly take the noun as an input (cf. Cinque, 2010). Positing (b) well-predicts readings where 'fake' is not apparently privative: 'fake watch' can designate a watch that is made to look like a Rolex but isn't one, i.e. a watch that is fake-as-a-Rolex. When the intersection between the [[fake]](*implicit argument*) complex and the noun is empty, rescuing principles originally proposed by Partee kick in to rescue from vacuous modification: this explains why we can refer to a fake gun as a gun, as in the sentence "this gun is fake". As a result, besides well-predicting iterated 'fake', this theory provides clear predictions on when and how Partee's pragmatic principles of noun modulation apply. I conclude the paper arguing that this view of privatives suggests a novel way of classifying adjectives, in terms of their compositional behavior rather than by their emergent entailment pattern.<table cellspacing="15" valign="top"><tr><td>Format: </td><td>[ <a href="/lingbuzz/006977/current.pdf">pdf</a> ]</td></tr><tr><td>Reference: </td><td>lingbuzz/006977<br/><font size="-1"> (please use that when you cite this article)</font></td></tr><tr><td>Published in: </td><td>(Accepted) Journal of Semantics</td></tr><tr><td>keywords: </td><td>privative adjectives, semantics</td></tr><tr><td>previous versions: </td><td><a href="/lingbuzz/006977/v1.pdf">v1 [December 2022]</a><br/></td></tr><tr><td>Downloaded:</td><td>927 times</td></tr></table><table cellspacing="15"><tr><p></p>&nbsp;<p></p>[ <a href="/lingbuzz/006977">edit this article</a> | <a href="/lingbuzz/006977">back to article list</a> ]</tr></table><script type="text/javascript">/*<![CDATA[*/function onLoad(){};/*]]>*/</script></body></html>